/* eslint-env node */
/* eslint-disable no-console */
import Ractive from '@ractivejs/core'
import { toParts, toModule } from '@ractivejs/utils-component'
import serialize from 'serialize-javascript'
import program from 'commander'

program
  .command('parse')
  .description('Takes templates and emits its JSON/JS AST form.')
  .option('-x, --no-csp', 'Do not output expression functions.')
  .option('-d, --delimiters [pair]', 'Start and end delimiters for normal mustaches.')
  .option('-s, --static-delimiters [pair]', 'Start and end delimiters for static mustaches.')
  .option('-t, --triple-delimiters [pair]', 'Start and end delimiters for triple mustaches.')
  .option('-p, --static-triple-delimiters [pair]', 'Start and end delimiters for static triple mustaches.')
  .option('-u, --escape-unicode', 'Export non-ASCII characters in strings as UTF escapes.')
  .action(cmd => {
    const { csp, delimiters: d, staticDelimiters: s, tripleDelimiters: t, staticTripleDelimiters: p } = cmd
    const x = d => d ? d.split(' ') : void 0
    readFromStream(process.stdin).then(template => {
      const parsed = Ractive.parse(template, { delimiters: x(d), staticDelimiters: x(s), tripleDelimiters: x(t), staticTripleDelimiters: x(p), csp })
      const serialized = serialize(parsed)
      const escaped = cmd.escapeUnicode ? escapeUnicode(serialized) : serialized
      const newlined = `${escaped}\n`
      return writeToStream(process.stdout, newlined)
    }, err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('parts')
  .description('Takes component files and emits its JSON parts form.')
  .action(() => {
    readFromStream(process.stdin).then(component => {
      return writeToStream(process.stdout, serialize(toParts(component)))
    }, err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('module')
  .description('Takes the output of the parts command and emits a module.')
  .action(() => {
    readFromStream(process.stdin).then(partsString => {
      return writeToStream(process.stdout, toModule({ source: '', file: '', parts: JSON.parse(partsString) }).code)
    }, err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program
  .command('sourcemap')
  .description('Takes the output of the parts command and emits a v3 source map.')
  .option('-s, --source <name>', 'The name of the source file.')
  .option('-f, --file <name>', 'The name of the destination file.')
  .action(cmd => {
    const { source, file } = cmd
    readFromStream(process.stdin).then(partsString => {
      const parts = JSON.parse(partsString)
      return writeToStream(process.stdout, JSON.stringify(toModule({ source, file, parts }).map))
    }, err => {
      console.error(err.message)
      process.exit(1)
    })
  })

program.parse(process.argv)

function readFromStream(stream) {
  return new Promise((resolve, reject) => {
    const data = []
    stream.on('data', chunk => data.push(chunk))
    stream.on('end', () => resolve(Buffer.concat(data).toString('utf8')))
    stream.on('error', reject)
  })
}

function writeToStream(stream, string) {
  return new Promise(resolve => {
    stream.on('drain', resolve)
    stream.write(string, 'utf8')
  })
}

// https://gist.github.com/mathiasbynens/1243213
function escapeUnicode(string) {
  return string.replace(/[^]/g, char => {
    const code = char.charCodeAt()

    if (code < 256) return char

    const escape = code.toString(16)
    const long = escape.length > 2
    return `\\${long ? 'u' : 'x'}${('0000' + escape).slice(long ? -4 : -2)}`
  })
}
